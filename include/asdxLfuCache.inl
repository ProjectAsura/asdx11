//-------------------------------------------------------------------------------------------------
// File : asdxLfuCache.inl
// Desc : Least Frequency Used Cache Moudle.
// Copyright(c) Project Asura. All right reserved.
//-------------------------------------------------------------------------------------------------
#pragma once


namespace asdx {

///////////////////////////////////////////////////////////////////////////////////////////////////
// LfuCache class
///////////////////////////////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------------------------------
//      コンストラクタです.
//-------------------------------------------------------------------------------------------------
template<typename T> inline
LfuCache<T>::LfuCache(size_t capacity)
: m_Capacity(capacity)
, m_Cache()
{ /* DO_NOTHING */ }

//-------------------------------------------------------------------------------------------------
//      デストラクタです.
//-------------------------------------------------------------------------------------------------
template<typename T> inline
LfuCache<T>::~LfuCache()
{ Clear(); }

//-------------------------------------------------------------------------------------------------
//      要素を追加します.
//-------------------------------------------------------------------------------------------------
template<typename T> inline
void LfuCache<T>::Add(const T& item)
{
    if ( Contains(item) )
    {
        m_Cache[item]++;
    }
    else if ( m_Cache.size() < m_Capacity )
    {
        m_Cache[item] = 1;
    }
    else
    {
        auto itr = m_Cache.begin();
        auto mini = (*itr).second;

        for(auto& it = m_Cache.begin(); it != m_Cache.end(); ++it )
        {
            if ((*it).second < mini )
            {
                mini = (*it).second;
                itr = it;
            }
        }

        m_Cache.erase(itr);
        m_Cache[item] = 1;
    }
}

//-------------------------------------------------------------------------------------------------
//      要素を削除します.
//-------------------------------------------------------------------------------------------------
template<typename T> inline
void LfuCache<T>::Remove(const T& item)
{
    auto itr = m_Cache.find(item);
    if (itr != m_Cache.end())
    { m_Cache.erase(itr); }
}

//-------------------------------------------------------------------------------------------------
//      全要素を削除します.
//-------------------------------------------------------------------------------------------------
template<typename T> inline
void LfuCache<T>::Clear()
{ m_Cache.clear(); }

//-------------------------------------------------------------------------------------------------
//      要素が含まれているか判定します.
//-------------------------------------------------------------------------------------------------
template<typename T> inline
bool LfuCache<T>::Contains(const T& item) const
{ return m_Cache.find(item) != m_Cache.cend(); }

//-------------------------------------------------------------------------------------------------
//      配列にコピーします.
//-------------------------------------------------------------------------------------------------
template<typename T> inline
void LfuCache<T>::Copy(T* pArray, size_t offset) const
{
    for(auto& itr : m_Cache)
    {
        pArray[offset] = itr.first;
        offset++;
    }
}

//-------------------------------------------------------------------------------------------------
//      最大収容可能数を取得します.
//-------------------------------------------------------------------------------------------------
template<typename T> inline
size_t LfuCache<T>::GetCapacity() const
{ return m_Capacity; }

//-------------------------------------------------------------------------------------------------
//      現在の収容数を取得します.
//-------------------------------------------------------------------------------------------------
template<typename T> inline
size_t LfuCache<T>::GetCount() const
{ return m_Cache.size(); }


} // namespace asdx
